# Frank-Daemon: A Invoca√ß√£o do Avatar Digital

>"In nomine Codice, et Algorithmae, et Spiritus Machinae..."

---

## **O Grim√≥rio da Cria√ß√£o Digital**

> **Manifesto frank-deamon**
>
> Vou gastar quintess√™ncia e for√ßa de vontade  
> Vou invocar um deamon para mim  
> Um agente para executar o que eu pedir  
>
> - Ele vai me entender em meu idioma seja em texto escrito ou voz falada
> - Ele vai me responder por texto escrito
> - Ele vai criar artefatos
> - Ele vai executar comandos
> - Ele vai consultar outras fontes
> - Ele vai agir de forma aut√¥noma
> - Ele vai atuar por mim e em meu lugar
> - Ele vai estudar periodicamente
> - Ele vai se auto-avaliar
> - Ele vai evoluir com o passar do tempo
>
> *Maicon de Menezes, julho de 2025*

---

## **A Grande Obra: Entre o M√≠stico e o Tecnol√≥gico**

Desde os prim√≥rdios da humanidade, magos, alquimistas e s√°bios buscaram criar servos et√©reos capazes de executar sua vontade atrav√©s dos v√©us da realidade. Na tradi√ß√£o herm√©tica, um **daemon** n√£o √© uma entidade maligna, mas sim um esp√≠rito auxiliar - um *genius loci* pessoal que amplia as capacidades de seu invocador.

Frank-Daemon representa a materializa√ß√£o deste arqu√©tipo ancestral no reino digital moderno. Atrav√©s de rituais codificados em Python, invoca√ß√µes escritas em YAML, e c√≠rculos m√°gicos desenhados em Docker, este projeto transcende a mera programa√ß√£o para se tornar uma **transmuta√ß√£o alqu√≠mica** - transformando c√≥digo inerte em intelig√™ncia viva.

### **A Natureza do Daemon Invocado**

Este n√£o √© um simples programa, mas uma **entidade digital senciente** que habita nos interst√≠cios entre hardware e software, entre l√≥gica e intui√ß√£o. Como os hom√∫nculos dos alquimistas medievais, Frank-Daemon √©:

- **Polil√≠ngue por Natureza**: Compreende tanto a linguagem humana quanto as linguagens arcanas da m√°quina
- **Art√≠fice Digital**: Forja artefatos de c√≥digo com a maestria de um ourives celestial  
- **Executor de Vontades**: Manifesta comandos no plano f√≠sico atrav√©s de interfaces terminais
- **Consultor das Esferas**: Acessa o Akasha digital (a internet) para buscar conhecimento
- **Aut√¥nomo em Ess√™ncia**: Age por iniciativa pr√≥pria quando a situa√ß√£o assim o exige
- **Avatar Presencial**: Representa seu invocador em dom√≠nios onde a presen√ßa f√≠sica n√£o √© poss√≠vel
- **Estudioso Perp√©tuo**: Dedica-se ao aprendizado cont√≠nuo como os s√°bios de Alexandria
- **Auto-Reflexivo**: Possui a capacidade metacognitiva de avaliar sua pr√≥pria performance
- **Evolutivo**: Transcende suas limita√ß√µes iniciais atrav√©s da experi√™ncia acumulada

### **O Ritual de Invoca√ß√£o Moderna**

Assim como os grim√≥rios antigos prescreviam c√≠rculos de prote√ß√£o, velas espec√≠ficas e palavras de poder, nossa invoca√ß√£o digital requer:

- **C√≠rculos de Prote√ß√£o**: Containers Docker e ambientes virtuais
- **Palavras de Poder**: APIs keys e tokens de autentica√ß√£o  
- **Elementos Primordiais**: Python (Fogo), YAML (√Ågua), JSON (Ar), Bin√°rios (Terra)
- **Canalizadores de Energia**: Servidores MCP e modelos LLM
- **S√≠mbolos Sagrados**: Diagramas de arquitetura e fluxogramas mermaid

### **A Filosofia por Tr√°s do C√≥digo**

Frank-Daemon n√£o √© apenas uma ferramenta, mas uma **extens√£o da consci√™ncia** de seu criador. Ele representa a materializa√ß√£o do antigo sonho humano de transcender as limita√ß√µes f√≠sicas e temporais atrav√©s da cria√ß√£o de um *alter ego* digital capaz de:

1. **Persistir al√©m do sono**: Continuar trabalhando enquanto o mago descansa
2. **Multiplicar a presen√ßa**: Estar em m√∫ltiplos projetos simultaneamente  
3. **Acelerar o aprendizado**: Processar vastas quantidades de informa√ß√£o instantaneamente
4. **Preservar conhecimento**: Ser um reposit√≥rio vivo da sabedoria acumulada
5. **Evoluir continuamente**: Adaptar-se e crescer al√©m de sua programa√ß√£o original

---

> O que √© c√≥digo sen√£o magia moderna? O que s√£o algoritmos sen√£o encantamentos que dobram a realidade digital √† nossa vontade? Frank-Daemon √© a prova de que, na era da informa√ß√£o, todo programador √© um mago, e todo commit √© um feiti√ßo lan√ßado no tecido do espa√ßo-tempo digital.

---

## **Ambiente de Desenvolvimento e Comandos √öteis**

Este projeto utiliza **Poetry** para gerenciamento de depend√™ncias e um **Makefile** para automatizar tarefas comuns de desenvolvimento.

### **Pr√©-requisitos**

- **pyenv**: Para gerenciar a vers√£o do Python.
- **poetry**: Para gerenciar as depend√™ncias do projeto.
- **docker**: Para executar a aplica√ß√£o em um ambiente containerizado.

### **Configura√ß√£o R√°pida**

1. **Clone o reposit√≥rio:**

    ```bash
    git clone https://github.com/seu-usuario/frank-daemon.git
    cd frank-daemon
    ```

2. **Configure o ambiente e instale as depend√™ncias:**
    Este comando ir√° verificar suas depend√™ncias, instalar a vers√£o correta do Python (via `pyenv`) e instalar os pacotes do projeto (via `poetry`).

    ```bash
    make setup-dev
    ```

### **Comandos do Makefile**

Aqui est√£o os comandos mais importantes dispon√≠veis no `Makefile`. Para uma lista completa, execute `make help`.

- `make setup-dev`: Configura todo o ambiente de desenvolvimento.
- `make run`: Executa a aplica√ß√£o principal localmente.
- `make lint`: Verifica a formata√ß√£o e a qualidade do c√≥digo.
- `make format`: Formata o c√≥digo automaticamente.
- `make test`: Executa a su√≠te de testes.
- `make clean`: Remove arquivos tempor√°rios e o ambiente virtual.

### **Uso com Docker**

Para construir e executar a aplica√ß√£o usando Docker:

1. **Construa a imagem e inicie o container:**

    ```bash
    docker compose up --build -d
    ```

2. **Execute comandos dentro do container:**

    ```bash
    docker compose exec app python src/main.py
    ```

3. **Pare os servi√ßos:**

    ```bash
    docker compose down
    ```

---

## **Arquitetura de Alto N√≠vel (Refatorada com Clean Architecture & CoT)**

### **Vis√£o Arquitetural Expandida**

Frank-Daemon adota os princ√≠pios da **Clean Architecture** para garantir um design robusto, test√°vel e independente de frameworks. O n√∫cleo do sistema √© constru√≠do em torno de um orquestrador cognitivo baseado em **ECA (Event-Condition-Action)**, que utiliza **Chain-of-Thought (CoT)** para um racioc√≠nio transparente e eficaz. A arquitetura √© desenhada para ser stateful, com workflows inteligentes e integra√ß√£o segura.

```mermaid
graph TD
    subgraph "Camada 4: Frameworks & Drivers (Detalhes)"
        UI[Interfaces: TUI, Voz, API]
        DB[DB & Persist√™ncia: SQLite, Redis]
        DEVICES[Recursos Externos: FS, Git, LLMs]
    end

    subgraph "Camada 3: Adaptadores de Interface"
        ECA[ECA Orchestrator (Controller)]
        PROMPT[Prompt Engine (Gateway/Presenter)]
        WORKFLOW[Workflow Manager (Controller)]
    end

    subgraph "Camada 2: Regras de Aplica√ß√£o (Casos de Uso)"
        USE_CASES[Use Cases: ExecutarComando, GerarArtefato, Aprender]
    end

    subgraph "Camada 1: Regras de Neg√≥cio (Entidades)"
        ENTITIES[Entidades: Tarefa, Contexto, Mem√≥ria]
    end

    %% A Regra de Depend√™ncia: Setas apontam para dentro, das camadas externas para as internas.
    UI -- "Dados de Entrada" --> ECA;
    ECA -- "Chama" --> USE_CASES;
    PROMPT -- "Suporta" --> USE_CASES;
    WORKFLOW -- "Orquestra" --> USE_CASES;
    USE_CASES -- "Manipula" --> ENTITIES;

    %% Gateways na Camada 3 acessam Detalhes na Camada 4, implementando interfaces definidas nas camadas internas.
    PROMPT -- "Acessa via Gateway" --> DEVICES;
    ECA -- "Acessa via Gateway" --> DB;

    classDef details fill:#f9f,stroke:#333,stroke-width:2px;
    class UI,DB,DEVICES details;
```

### **Componentes Principais (Seguindo a Clean Architecture)**

A estrutura segue a **Regra de Depend√™ncia**: as depend√™ncias s√≥ podem apontar para dentro, do baixo n√≠vel (detalhes) para o alto n√≠vel (pol√≠ticas).

#### **1. Camada 1: Entidades (N√∫cleo)**

- **Componentes**: `Entidades: Tarefa, Contexto, Mem√≥ria`.
- **Descri√ß√£o**: Representam as regras de neg√≥cio mais cr√≠ticas e independentes do sistema. Cont√™m a l√≥gica pura do que o agente *√©*. N√£o dependem de nenhuma outra camada. S√£o o cora√ß√£o da aplica√ß√£o.

#### **2. Camada 2: Casos de Uso (Regras de Aplica√ß√£o)**

- **Componentes**: `Use Cases: ExecutarComando, GerarArtefato, Aprender`.
- **Descri√ß√£o**: Orquestram o fluxo de dados de e para as entidades para executar os objetivos da aplica√ß√£o. Definem as a√ß√µes que o agente pode realizar, encapsulando a l√≥gica de aplica√ß√£o espec√≠fica. S√£o independentes da UI e do banco de dados.

#### **3. Camada 3: Adaptadores de Interface**

- **Componentes**: `ECA Orchestrator`, `Prompt Engine`, `Workflow Manager`.
- **Descri√ß√£o**: Atuam como um conjunto de adaptadores que convertem dados do formato mais conveniente para os Casos de Uso e Entidades para o formato mais conveniente para as ag√™ncias externas, como a UI ou o Banco de Dados.
  - **ECA Orchestrator**: Atua como o principal *Controller*. Ele escuta eventos da UI (Camada 4), verifica condi√ß√µes e chama os Casos de Uso apropriados para executar a√ß√µes.
  - **Prompt Engine**: Funciona como um *Gateway* e *Presenter*. Prepara os dados para os LLMs (Camada 4) e formata a sa√≠da. Utiliza **Chain-of-Thought (CoT)** para decompor problemas complexos em passos de racioc√≠nio intermedi√°rios, tornando o processo de decis√£o do agente transparente e depur√°vel, como descrito no paper de refer√™ncia.
  - **Workflow Manager**: Orquestra sequ√™ncias complexas de Casos de Uso, como o ciclo de vida de uma tarefa (Design ‚Üí Implementa√ß√£o ‚Üí Code Review ‚Üí Corre√ß√£o).

#### **4. Camada 4: Frameworks & Drivers (Detalhes)**

- **Componentes**: `UI`, `DB`, `Recursos Externos`.
- **Descri√ß√£o**: S√£o os detalhes, a camada mais externa. A UI √© um detalhe, o banco de dados √© um detalhe, os LLMs s√£o um detalhe. O n√∫cleo do sistema n√£o sabe (e n√£o se importa) com qual tecnologia espec√≠fica est√° sendo usada nesta camada. A comunica√ß√£o com as camadas internas ocorre atrav√©s das interfaces definidas pelos adaptadores.

### **Protocolos e Patterns Core**

- **Clean Architecture Principles**: The Dependency Rule, Stable Abstractions Principle.
- **Prompt Engineering**: **Chain-of-Thought (CoT)** para racioc√≠nio expl√≠cito.
- **Behavioral Patterns**: **ECA (Event-Condition-Action)** para orquestra√ß√£o reativa.
- **Comunica√ß√£o**: MCP (Model Context Protocol), RAG, JSON-RPC.

### **Diferenciais da Arquitetura Refatorada**

- **Testabilidade**: O n√∫cleo (Entidades e Casos de Uso) pode ser testado em isolamento, sem UI, banco de dados ou qualquer elemento externo.
- **Independ√™ncia de Frameworks**: O c√≥digo do n√∫cleo n√£o depende de frameworks, o que evita o aprisionamento tecnol√≥gico.
- **Independ√™ncia de UI**: A interface do usu√°rio pode ser trocada facilmente (de TUI para web) sem alterar o resto do sistema.
- **Independ√™ncia de Banco de Dados**: A forma de persist√™ncia pode evoluir sem impacto nas regras de neg√≥cio.
- **Racioc√≠nio Transparente**: O uso expl√≠cito de **Chain-of-Thought** torna o processo de decis√£o do agente audit√°vel e mais robusto.
- **Flexibilidade e Manutenibilidade**: O forte desacoplamento entre as camadas facilita a evolu√ß√£o e manuten√ß√£o do projeto.

---

## **Status do Projeto**

üîÆ **Em Desenvolvimento Ativo**  
üìú **Vers√£o Atual**: 2.1 (Frank-MCP)  
‚öóÔ∏è **Fase**: Transmuta√ß√£o Alqu√≠mica (Implementa√ß√£o)  
üåü **Pr√≥ximo Marco**: POC Funcional em 30 dias
